package cn.eas.usdk.demo.view.pinpad;

import android.os.Bundle;
import android.os.RemoteException;
import android.view.View;
import android.widget.Button;

import com.usdk.apiservice.aidl.device.DeviceInfo;
import com.usdk.apiservice.aidl.device.UDeviceManager;
import com.usdk.apiservice.aidl.pinpad.AuthInfo;
import com.usdk.apiservice.aidl.pinpad.AuthOut;
import com.usdk.apiservice.aidl.pinpad.KAPId;
import com.usdk.apiservice.aidl.pinpad.KMSMode;
import com.usdk.apiservice.aidl.pinpad.KeyType;
import com.usdk.apiservice.aidl.pinpad.PinpadError;
import com.usdk.apiservice.aidl.pinpad.ReqInfo;
import com.usdk.apiservice.aidl.pinpad.SignOut;

import cn.eas.usdk.demo.DeviceHelper;
import cn.eas.usdk.demo.R;
import cn.eas.usdk.demo.constant.DemoConfig;
import cn.eas.usdk.demo.rkis.KmsCommunication;
import cn.eas.usdk.demo.rkis.ResponseHandler;
import cn.eas.usdk.demo.rkis.RkisManager;
import cn.eas.usdk.demo.rkis.message.Response;
import cn.eas.usdk.demo.rkis.message.ReturnCode;
import cn.eas.usdk.demo.rkis.message.RkisTLVList;
import cn.eas.usdk.demo.rkis.message.RkisTag;
import cn.eas.usdk.demo.util.BytesUtil;

import static com.usdk.apiservice.aidl.pinpad.KMSMode.SCHEME_V2;

/**
 * Terms and definitions
 * CApos - Sub-CA Center, which uses its private key to sign the public key of the POS.
 *         It issues a root certificate and a work certificate, and the root certificate
 *         is used to verify the work certificate.
 * CERTpos - POS certificate, issued by the CApos Center.
 * CERTkms - KMS certificate, issued by the CAkms Center.
 * R1 - 随机会话特征码分量, 用作密钥分发过程的会话特征码。1表示第一阶段，由终端产生
 *      Random session signature weight, which is used as a session signature for the key
 *      distribution process. 1 indicates the first stage, which is generated by the terminal
 * R2 - Generated by KMS
 * PUpos - Terminal public key
 * PUkms - KMS public key
 * PRpos - The private key of the terminal is pre installed at the factory and pre installed with the certificate
 * PRkms - KSM private key
 * CODE - Key injection request code, currently customer number
 * INFpos - POS information, consisting of the hardware serial number, terminal number, and merchant number
 *
 * KE - 由 KMS 生成的短暂性 TDEA 密钥，用于加密 POS 与 KMS 之间交换的密钥块数据 KBn
 * EK - 短暂性密钥密文（Ephemeral  Key）的简称，由 PUpos 加密 KE 得到的密文数据。
 * KBH - 密钥块头信息（Key Block Header） 的简称，TR-31 的密钥块头信息格式，包含指示密钥块内容的相关信息。
 * KBS - 使用 KE 密钥对 KBS_CLEAR 进行 CBC 加密得到的密文。其中，使用 KBH 的前 8 字节数据的 HEX 码串作为 CBC 模式加密的 IV 值
 * KBS_CLEAR - 使用非对称密钥机制分发对称密钥
 *
 * KE - A transient TDEA key generated by KMS that encrypts the key block data KBn exchanged between POS and KMS
 * EK - Short for Ephemeral Key, the secret data obtained by PUpos Encrypted KE.
 * KBH - Short for Key Block Header, The key block information format for TR-31, which contains information that indicates the contents of the key block.
 * KBS - Get ciphertext by useing the KE key to encrypte KBS_CLEAR in CBC mode, the HEX string of the first 8 bytes of KBH data is used as an IV value encrypted in CBC mode
 * KBS_CLEAR - Using asymmetric key mechanism to distribute symmetric key
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * 1. 前期POS环境准备（出厂预装：pos证书+pos私钥+kms根证书）
 * - 通过专门的密钥下载工具，将POS的型号及序列号上送KMS, KMS生成该终端特有的证书，下发给工具，最终下装到POS
 * - POS证书：与机器的型号，序列号绑定；一台终端只签发一本。（证书本身是公开的）
 * （1）pos证书，用于指明终端的合法性，KMS通过 pos 根证书来验证
 * （2）pos私钥，用于签名INFpos（KMS通过pos公钥解密SINF_POS后，与INFpos比对，如果一致，说明终端合法）
 * （3）kms根证书，用于验证 kms 的工作证书，实现验证KMS的合法性。
 *
 *1. Preparation of POS environment (factory pre installed: POS certificate + POS private key + kms root certificate)
 * - By using the special key download tool, the model and serial number of POS are sent to KMS. Kms generates the
 *   specific certificate of the terminal, issues it to the tool, and finally loads it to POS.
 * - POS certificate: binding to the machine's model number and serial number; one terminal only issues one certificate. (the certificate itself is public)
 * (1) POS certificate is used to indicate the validity of the terminal. Kms verifies it by POS root certificate.
 * (2) Pos private key, used to sign INFpos (KMS decrypts the SINF_POS through pos public key, then compared to INFpos, if consistent, indicates that the terminal is legal)
 * (3) Kms root certificate, which is used to verify the working certificate of kms and to verify the legitimacy of KMS.
 *
 * 2. 远程下载密钥过程
 * POS（1）APP获取CERTpos、R1、SN(后标牌那个)、HardWareSn（后台要求）、Model、Manufacture，组包上送给KMS
 * KMS（2）KMS 用根证书验证CERTPOS合法性、确定SNPOS准入性 -> 从CERTpos中取出PUpos -> 准备并下发认证证书链CERT_AUTHKMS-1，CERT_AUTHKMS-2，CERTKMS
 *      每本认证证书都独立下发，即完成证书链下发需要发送3次
 * POS（3）逐级认证CERTKMS合法性，确定ID KMS正确性，认证顺序: CERT_AUTHKMS-1 -> CERT_AUTHKMS-1 -> CERTKMS
 *      得到CERTkms中心编号ID KMS, 证书公钥PUkms
 *      合成随机会话特征码R= R1^ R2
 *      准备密钥注入请求代码CODE和相关信息INFpos
 *      使用PRpos对INFpos 进行数据签名，得到SINF_POS
 *      -> 上送R、CODE、INFpos、SINF_POS
 * KMS（4）合成并比对会话特征码R= R1^ R2
 *         验证终端数据签名V(SINF_POS, PUpos)
 *         生成临时密钥加密密钥EK=E(KE, PUpos)
 *         组织密钥块头信息KBH(TR-31格式)
 *         根据CODE和INFpos信息，组织密钥块KBS=ECBC(KBH, KBS_CLEAR, KE)
 *         使用PRkms进行签名得到SKMS=S(R||EK||KBH||KBS, PRKMS)
 * POS（5）比对会话特征码R
 *         使用PUkms 验证SKMS 得到 S
 *         解密EK得到KE=D(EK, PRPOS)( 终端通过PRpos解密EK,得到 KE)
 *         解密KBS，DCBC(KBH,  KBS, KE)后依次得到KBn
 *         解密得到Kn=D(KB n, K E)，并校验KCV Kn
 *         依次存储密钥Kn
 *
 * 2. The remote download key process
 * POS (1) APP gets CERTpos, R1, SN, HardWareSn, Model, Manufacture, and sends the package to KMS.
 * KMS（2）KMS verifies the legitimacy of CERTPOS with the root certificate, determines SNPOS access
 *      - > get PUpos from CERTpos - > Prepare and issue the certification certificate chain CERT_AUTHKMS-1,CERT_AUTHKMS-2, CERTKMS
 *      Each certification certificate is issued independently,  that is need 3 times to complete the certificate chain issue
 * POS（3）Step-by-step certification of CERTKMS legitimacy, determination of ID KMS correctness, certification order: CERT_AUTHKMS-1 -> CERT_AUTHKMS-1 -> CERTKMS
 *      Get CERTkms center number ID KMS, certificate public key PUkms
 *      Synthetic random session signature R = R1 ^ R2
 *      Prepare key injection request code CODE and related information INFpos
 *      Use PRpos to sign INFpos data and get SINF_POS
 *      -> Send R, CODE, INFpos, SINF_POS to KMS
 * KMS（4）Synthesized and compared session signature R = R1 ^ R2
 *      Verify Terminal Data Signature V (SINF_POS, PUpos)
 *      Generate the key to encrypted temporary key EK=E(KE, PUpos)
 *      Organize Key Block Information KBH (TR-31 format)
 *      According to CODE and INFpos, the key block KBS = ECBC (KBH, KBS_CLEAR, KE)
 *      Sign with PRkms to get SKMS=S(R||EK||KBH||KBS, PRKMS)
 *POS（5）Compared to session signature R
 *      Using PUkms to verify SKMS to get S
 *      Decrypt EK to get KE， KE = D (EK, PRPOS) (the terminal decrypts EK through PRPOS and gets KE)
 *      Decrypt KBS, DCBC (KBH, KBS, KE) and get KBn
 *      Decrypt to get Kn= D(KBn, KE), verify KCV and Kn
 *      Store key Kn in turn
 */
public class RkisActivity extends BasePinpadActivity implements KmsCommunication.SocketListener {

    private UDeviceManager deviceManager;
    private RkisManager rkisManager = new RkisManager(this);

    private Button startRkisBtn;

    @Override
    protected void initDeviceInstance() {
        deviceManager = DeviceHelper.me().getDeviceManager();
    }

    @Override
    protected void onCreateView(Bundle savedInstanceState) {
        super.onCreateView(savedInstanceState);
        setContentView(R.layout.activity_pinpad_rkis);
        setTitle("RKIS V2/V3 Module");
        initView();
    }

    private void initView() {
        startRkisBtn = bindViewById(R.id.startRkisBtn);
        setSettingClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                startActivity(RkisSettingActivity.class);
            }
        });
    }

    @Override
    protected void onResume() {
        super.onResume();
        initRKISManager();
        initPinpadInstance();
    }

    private void initRKISManager() {
        try {
            DeviceInfo deviceInfo =  deviceManager.getDeviceInfo();
            rkisManager.setHardWareSn(deviceInfo.getHardWareSn());
            rkisManager.setManufacture(deviceInfo.getManufacture());
            rkisManager.setModel(deviceInfo.getModel());
            rkisManager.setSerialNo(deviceInfo.getSerialNo());
            rkisManager.setMerchantNo(DemoConfig.MERCH_ID);
            rkisManager.setTerminalNo(DemoConfig.TERM_ID);
            rkisManager.setURL(DemoConfig.KMS_IP, DemoConfig.KMS_PORT);
            rkisManager.setSocketListener(this);
        } catch (Exception e) {
            handleException(e);
        }
    }

    private void initPinpadInstance() {
        pinpad = createPinpad(new KAPId(DemoConfig.RKIS_REGION_ID, DemoConfig.RKIS_KAP_NUM), DemoConfig.RKIS_KEY_SYSTEM, DemoConfig.PINPAD_DEVICE_NAME);
        open();
    }

    @Override
    public void onPause() {
        super.onPause();
        close();
    }

    public void startRKIS(View v) {
        outputBlackText("\n>>>>>>>>>> start remote key injection <<<<<<<<<");

        hideSoftInput();
        setStartButtonEnabled(false);

        rkisTemplate.run();
    }

    private Runnable rkisTemplate = new Runnable() {
        @Override
        public void run() {
            // 1. 获取终端证书CERT，并生成随机会话特征码分量R
            // 1. Get the terminal certificate CERT and generate random session signature part R.
            initRemoteKeyLoadProc(new NextOperation<ReqInfo>() {
                @Override
                public void run(final ReqInfo reqInfo) {
                    // 2. 双向认证：KMS认证POS证书 -> POS逐级认证KMS证书
                    // 2. Mutual authentication: KMS authentication POS certificate > POS authentication KMS certificate level by level.
                    mutualAuth(reqInfo, new NextOperation<AuthOut>() {
                        @Override
                        public void run(final AuthOut authOut) {
                            // 3. 验证客户ID，并获取签名信息
                            // 3. Verify the customer ID and get signature information.
                            checkCIDandSignData(reqInfo, new NextOperation<SignOut>() {
                                @Override
                                public void run(SignOut signOut) {
                                    // 4. 密钥远程注入：从KMS请求密钥块，并下发到PIN-Pad
                                    // 4. Remote key injection: the key block is requested from KMS and inject to PIN-Pad.
                                    injectRemoteKey(authOut.getR(), reqInfo.getTerminalCrt_E(), signOut.getSignature());
                                }
                            });
                        }
                    });
                }
            });
        }
    };

    private void initRemoteKeyLoadProc(NextOperation next) throws IllegalStateException {
        outputBlueText(">>> initRemoteKeyLoadProc");
        try {
            ReqInfo reqInfo = new ReqInfo();
            int ret = pinpad.initRemoteKeyLoadProc(DemoConfig.KMS_MODE, reqInfo);
            if (ret != PinpadError.SUCCESS) {
                outputRedText("initRemoteKeyLoadProc fail: " + getErrorDetail(ret));
                return;
            }
            outputText("initRemoteKeyLoadProc success");

            next.run(reqInfo);
        } catch (Exception e) {
            handleException(e);
        }
    }

    /**
     * Mutual authentication
     */
    private void mutualAuth(ReqInfo reqInfo, final NextOperation<AuthOut> next) {
        outputBlueText(">>> requestAuthPOSCrt... ... ");
        if (reqInfo == null) {
            outputRedText("reqInfo is null ");
            return;
        }
        rkisManager.requestAuthPOSCrt(reqInfo.getR1(), reqInfo.getTerminalCrt(), new ResponseHandler() {
            @Override
            public boolean handle(Response response) {
                outputText("=> handle Response");
                RkisTLVList rkisTLVList = RkisTLVList.fromBinary(response.getMessageContent());
                if (isRespondFail(rkisTLVList)) {
                    return false;
                }
                Response.MessageHead messageHead = response.getMessageHead();
                return authKMSCrt(messageHead, rkisTLVList, next);
            }
        });
    }

    /**
     * Certified KMS certificate
     * @return true - success; false - failure
     */
    private boolean authKMSCrt(Response.MessageHead messageHead, RkisTLVList rkisTLVList, NextOperation<AuthOut> next) {
        int sumSn = messageHead.getSum();
        int currentSn = messageHead.getCurrentSn();
        outputBlueText(String.format(">>> authKMSCrt | sumSn = %s, currentSn = %s", sumSn, currentSn));

        try {
            byte[] R2 = rkisTLVList.getTLV(RkisTag.SESSION_ID).getValue();
            byte[] certKms = rkisTLVList.getTLV(RkisTag.CERT_KMS).getValue();
            int startIndex = 2;
            byte[] certData = BytesUtil.subBytes(certKms, startIndex, certKms.length - startIndex);

            AuthInfo authInfo = new AuthInfo(R2, sumSn, currentSn, certData);
            AuthOut authout = new AuthOut();
            int ret = pinpad.authKMSCrt(DemoConfig.KMS_MODE, authInfo, authout);
            if (ret != PinpadError.SUCCESS) {
                outputRedText("authKMSCrt fail: " + getErrorDetail(ret));
                return false;
            }
            if (! authout.isAuthSucc()) {
                outputRedText(String.format("!!! KMS crt auth fail(authState = 0x%02X)", authout.getAuthState()));
                return false;
            }
            outputText("=> authKMSCrt success");

            if (currentSn == sumSn) {
                next.run(authout);
            }
            return true;

        } catch (Exception e) {
            handleException(e);
            return false;
        }
    }

    private void checkCIDandSignData(ReqInfo reqInfo, NextOperation<SignOut> next) throws IllegalStateException {
        outputBlueText(">>> checkCIDandSignData");
        try {
            SignOut signOut = new SignOut();
            int ret = pinpad.checkCIDandSignData(DemoConfig.KMS_MODE, getCID(),  getSignData(reqInfo.getTerminalCrt_E()), signOut);
            if (ret != PinpadError.SUCCESS) {
                outputRedText("checkCIDandSignData fail: " + getErrorDetail(ret));
                return;
            }
            if (!signOut.isValidCID()) {
                outputRedText("CID is invalid !");
                return;
            }
            outputText("=> checkCIDandSignData success");

            next.run(signOut);
        } catch (Exception e) {
            handleException(e);
        }
    }

    private void injectRemoteKey(byte[] R, byte[] terminalCrtE, byte[] signature) {
        outputBlueText(">>> requestRemoteKey... ... ");
        rkisManager.requestRemoteKey(R, terminalCrtE, signature, new ResponseHandler() {
            @Override
            public boolean handle(Response response) {
                outputText("=> handle Response");
                RkisTLVList rkisTLVList = RkisTLVList.fromBinary(response.getMessageContent());
                if (isRespondFail(rkisTLVList)) {
                    return false;
                }

                return loadRKISv2RemoteKey(rkisTLVList);
            }
        });
    }

    private boolean loadRKISv2RemoteKey(RkisTLVList rkisTLVList) throws IllegalStateException {
        outputBlueText(">>> loadRKISv2RemoteKey... ... ");
        try {
            int mode = DemoConfig.KMS_MODE | DemoConfig.LRKM_MODE;
            int keyId = DemoConfig.RKIS_KEY_ID;
            int ret = pinpad.loadRKISv2RemoteKey(mode, keyId, parseForEnckey(rkisTLVList));
            if (ret != PinpadError.SUCCESS) {
                outputRedText("loadRKISv2RemoteKey fail: " + getErrorDetail(ret));
                return false;
            }
            outputText("=> loadRKISv2RemoteKey success");

            setStartButtonEnabled(true);
            return true;
        } catch (Exception e) {
            handleException(e);
            return false;
        }
    }

    /**
     * Each part is made up (4-byte length sorted by big end + n-byte Value)
     * SESSION_ID + EPHEMERAL_KEY + SECRECY_DATA_BLOCK(first 16 bytes) + SECRECY_DATA_BLOCK(remaining bytes) + SIGN_DATA
     */
    private byte[] parseForEnckey(RkisTLVList rkisTLVList) {
        byte[] sessionID = rkisTLVList.getTLV(RkisTag.SESSION_ID).getValue();
        byte[] sessionIDLen = BytesUtil.intToBytesByHigh(sessionID.length);

        byte[] ephemeralKey = rkisTLVList.getTLV(RkisTag.EPHEMERAL_KEY).getValue();
        byte[] ephemeralKeyLen = BytesUtil.intToBytesByHigh(ephemeralKey.length);

        byte[] secrecyDataBlock = rkisTLVList.getTLV(RkisTag.SECRECY_DATA_BLOCK).getValue();
        final int PRE_LEN = 16;
        byte[] preLen = BytesUtil.intToBytesByHigh(PRE_LEN);
        byte[] preValue = BytesUtil.subBytes(secrecyDataBlock, 0, PRE_LEN);

        final int RES_LEN = secrecyDataBlock.length - PRE_LEN;
        byte[] resLen = BytesUtil.intToBytesByHigh(RES_LEN);
        byte[] resValue = BytesUtil.subBytes(secrecyDataBlock, PRE_LEN, RES_LEN);

        byte[] signData = rkisTLVList.getTLV(RkisTag.SIGN_DATA).getValue();
        byte[] signDataLen = BytesUtil.intToBytesByHigh(signData.length);

        return BytesUtil.merage(sessionIDLen, sessionID, ephemeralKeyLen, ephemeralKey,
                preLen, preValue, resLen, resValue, signDataLen, signData);
    }

    /**
     * Check whether KMS response is successful
     */
    private boolean isRespondFail(RkisTLVList rkisTLVList) throws IllegalStateException {
        String retCode = new String(rkisTLVList.getTLV(RkisTag.RET_CODE).getValue());
        if (ReturnCode.SUCCESS.equals(retCode)) {
            return false;
        }
        outputRedText("KMS return error: " + rkisManager.getRetInfo(retCode));
        return true;
    }

    private byte[] getCID() {
        return  DemoConfig.KMS_ID.getBytes();
    }

    /**
     * Data to be signed
     * RKIS V2: HardWareSn || TerminalNo || MerchantNo
     * RKIS V3: HardWareSn || TerminalNo || MerchantNo || req
     */
    private byte[] getSignData(byte[] certPosE) {
        byte[] posInfo = (rkisManager.getHardWareSn() + rkisManager.getTerminalNo() + rkisManager.getMerchantNo()).getBytes();
        switch (DemoConfig.KMS_MODE) {
            //extension api
//            case KMSMode.SCHEME_V1:
//                return posInfo;
            case SCHEME_V2:
            default:
                return BytesUtil.merage(posInfo, certPosE);
        }
    }

    @Override
    public void onConnected() {
        outputBlackText("=> onConnected");
    }

    @Override
    public void onSended(byte[] sendData) {
        outputBlackText("=> onSended");
    }

    @Override
    public void onReceviced(byte[] receData) {
        outputBlackText("=> onReceviced");
    }

    @Override
    public void onError(int errCode, String errInfo) {
        outputRedText("=> onError | " + errInfo);
    }

    @Override
    protected void outputRedText(String text) {
        super.outputRedText(text);
        setStartButtonEnabled(true);
    }

    private void setStartButtonEnabled(final boolean enabled) {
        uiHandler.post(new Runnable() {
            @Override
            public void run() {
                startRkisBtn.setEnabled(enabled);
            }
        });
    }

    protected interface NextOperation<T> {
       void run(T param);
    }

    // 测试后台主密钥：123456789012345678901234567890123456789012345678
    // 正式后台主密钥：313131313131313131313131313131313131313131313131
    public void loadEncKey(View view) {
        outputBlueText(">>> loadEncKey");
        open();
        try {
            int[] keyIds = new int[] {KEYID_PIN, KEYID_MAC, KEYID_TRACK, KEYID_DES};
            int[] keyTypes = new int[] {KeyType.PIN_KEY, KeyType.MAC_KEY, KeyType.TDK_KEY, KeyType.DEK_KEY};
            String[] keys;
            if (DemoConfig.KMS_IP.equals("kdptest.unimarspay.com")) {
                // 测试后台
                keys = new String[]{
                        // 全9
                    "036B3552ADB05916036B3552ADB05916036B3552ADB05916",
                    // 全8
                    "132B3E7984E5E460132B3E7984E5E460132B3E7984E5E460",
                    // 全7
                    "C4838A839907C042C4838A839907C042C4838A839907C042",
                    // 全6
                    "FF8ABDA2BA9F8325FF8ABDA2BA9F8325FF8ABDA2BA9F8325"
                };
            }else {
                // 正式后台
                keys = new String[]{
                        // 全9
                        "4CE6926A7B02FF1D4CE6926A7B02FF1D4CE6926A7B02FF1D",
                        //
                        "7B7EEFD58E21A2737B7EEFD58E21A2737B7EEFD58E21A273",
                        //
                        "B01C66FD244B961AB01C66FD244B961AB01C66FD244B961A",
                        //
                        "7DAC274818D688717DAC274818D688717DAC274818D68871"
                };
            }


            String[] kcvs = new String[] {
                    "0F2FCF4A",
                    "F9F4FBD3",
                    "4CBE91BE",
                    "B0B563C2"
            };
            for (int i = 0; i < keyIds.length; i++) {
                int keyType = keyTypes[i];
                int keyId = keyIds[i];
                boolean isSucc = pinpad.loadEncKey(keyType, DemoConfig.RKIS_KEY_ID, keyId, BytesUtil.hexString2Bytes(keys[i]), BytesUtil.hexString2Bytes(kcvs[i]));
                if (isSucc) {
                    outputText(String.format("loadEncKey(keyType = %s, keyId = %s) success",keyType, keyId));
                } else {
                    outputPinpadError(String.format("loadEncKey(keyType = %s, keyId = %s) fail",keyType, keyId));
                }
            }
            //close();
        } catch (RemoteException e) {
            outputRedText("RemoteException: " + e.getMessage());
        }
    }

    public void deleteKey(View view) {
        open();
        int[] keyIds = new int[] {DemoConfig.RKIS_KEY_ID, KEYID_PIN, KEYID_MAC, KEYID_TRACK, KEYID_DES};
        deleteKey(keyIds);
        //close();
    }
}
